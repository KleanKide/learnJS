// Создайте декоратор spy(func), который должен возвращать
//  обёртку, которая сохраняет все вызовы функции в своём свойстве calls.

function spy(func) {

  function wrapper(...args) {
    wrapper.calls.push(args);
    return func.apply(this, args);
  }

  wrapper.calls = [];

  return wrapper;
}

// Задерживающий декоратор
// важность: 5
// Создайте декоратор delay(f, ms), который задерживает каждый вызов f на ms миллисекунд. 

function delay(f, ms) {

  return function() {
    setTimeout(() => f.apply(this, arguments), ms);
  };

}

let f1000 = delay(alert, 1000);

f1000("test");

// Декоратор debounce
//  Предположим, пользователь набирает какой-то текст, и мы хотим отправить запрос на сервер,
//   когда ввод этого текста будет завершён.

// Нет смысла отправлять запрос для каждого набранного символа. 
// Вместо этого мы хотели бы подождать, а затем обработать весь результат.

// В браузере мы можем настроить обработчик событий – функцию, которая вызывается при каждом изменении
//  поля для ввода. Обычно обработчик событий вызывается очень часто, для каждого набранного символа.
//   Но если мы воспользуемся debounce на 1000мс, то он будет вызван только один раз, 
//   через 1000мс после последнего ввода символа.

function debounce(func, ms) {
  let timeID;
  return function() {
    clearTimeout(timeout);
    timeID = setTimeout(() => func.apply(this, arguments), ms);
  };
}